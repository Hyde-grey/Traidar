/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/3dModels/TraidarLogoDiffused.glb -types 
*/

import * as THREE from "three";
import { type JSX, useRef, useMemo } from "react";
import { useGLTF, Environment } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useFrame } from "@react-three/fiber";

type GLTFAction = THREE.AnimationClip;

type GLTFResult = GLTF & {
  nodes: {
    Sphere: THREE.Mesh;
    Logo: THREE.Mesh;
  };
  materials: {};
  animations: GLTFAction[];
};

export function TraidarDiffusedModel(props: JSX.IntrinsicElements["group"]) {
  const { nodes } = useGLTF(
    "/3dModels/TraidarLogoDiffused.glb"
  ) as unknown as GLTFResult;

  const sphereRef = useRef<THREE.Mesh>(null);
  const particlesRef = useRef<THREE.Points>(null);

  // Create particles from the logo geometry
  const particles = useMemo(() => {
    if (!nodes.Logo.geometry) return null;

    const geometry = new THREE.BufferGeometry();
    const positions = nodes.Logo.geometry.attributes.position.array;
    const particleCount = positions.length / 3;

    // Store original positions and create scales
    const originalPositions = new Float32Array(positions);
    const scales = new Float32Array(particleCount);
    geometry.setAttribute(
      "position",
      new THREE.BufferAttribute(new Float32Array(positions), 3)
    );
    geometry.setAttribute("scale", new THREE.BufferAttribute(scales, 1));

    return {
      geometry,
      originalPositions,
    };
  }, [nodes.Logo.geometry]);

  // Animation and interaction logic
  useFrame(() => {
    if (!sphereRef.current || !particlesRef.current || !particles) return;

    const spherePosition = sphereRef.current.position;
    const positions = particlesRef.current.geometry.attributes.position;
    const scales = particlesRef.current.geometry.attributes.scale;

    for (let i = 0; i < positions.count; i++) {
      const originalX = particles.originalPositions[i * 3];
      const originalY = particles.originalPositions[i * 3 + 1];
      const originalZ = particles.originalPositions[i * 3 + 2];

      const particlePosition = new THREE.Vector3(
        originalX,
        originalY,
        originalZ
      );
      const distance = particlePosition.distanceTo(spherePosition);

      // Map range similar to your Blender setup
      const fromMin = 0;
      const fromMax = 2;
      const toMin = 1;
      const toMax = 0;

      // Linear interpolation with clamping
      const influence = Math.max(
        0,
        Math.min(1, (distance - fromMin) / (fromMax - fromMin))
      );
      const scale = toMin + (toMax - toMin) * influence;

      positions.setXYZ(i, originalX, originalY, originalZ);

      scales.setX(i, scale);
    }

    positions.needsUpdate = true;
    scales.needsUpdate = true;
  });

  return (
    <group {...props} dispose={null}>
      <Environment preset="studio" />
      <mesh
        ref={sphereRef}
        castShadow
        receiveShadow
        geometry={nodes.Sphere.geometry}
        position={[-1.009, 0, 3.158]}
        scale={0.2}
        onPointerMove={(e) => {
          e.stopPropagation();
          const x = e.point.x;
          const y = e.point.y;
          const z = e.point.z;
          e.object.position.set(x, y, z);
        }}
      >
        <meshBasicMaterial color="#ffffff" transparent opacity={0.2} />
      </mesh>

      {particles && (
        <points
          ref={particlesRef}
          geometry={particles.geometry}
          rotation={[Math.PI / 2, 0, Math.PI / 2]}
        >
          <pointsMaterial
            size={0.05}
            color="#ffffff"
            transparent
            opacity={0.8}
            sizeAttenuation
            vertexColors
          >
            <primitive
              attach="map"
              object={new THREE.TextureLoader().load("/circle.png")}
            />
          </pointsMaterial>
        </points>
      )}
    </group>
  );
}

useGLTF.preload("/3dModels/TraidarLogoDiffused.glb");
